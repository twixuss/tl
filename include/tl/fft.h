#pragma once
#include "complex.h"

namespace TL {

template <class Float>
bool fft(Span<Complex<Float>> span) {
	u32 N = span.size;
	if (!is_power_of_2(N)) return false;

	u32 LogN = TL::log2(N);
	if (LogN < 2 || LogN > 24) return false;

	static constexpr Complex<Float> ws[] = {
		{-1,                                         0                                               },
		{0,                                          -1                                              },
		{0.7071067811865475244008443621048490392848, 0.7071067811865475244008443621048490392848      },
		{0.9238795325112867561281831893967882868224, 0.3826834323650897717284599840303988667613      },
		{0.9807852804032304491261822361342390369739, 0.1950903220161282678482848684770222409277      },
		{0.9951847266721968862448369531094799215755, 0.09801714032956060199419556388864184586114     },
		{0.9987954562051723927147716047591006944432, 0.04906767432741801425495497694268265831475     },
		{0.9996988186962042201157656496661721968501, 0.02454122852291228803173452945928292506547     },
		{0.9999247018391445409216464911963832243506, 0.01227153828571992607940826195100321214037     },
		{0.9999811752826011426569904377285677161739, 0.006135884649154475359640234590372580917058    },
		{0.9999952938095761715115801257001198995530, 0.003067956762965976270145365490919842518945    },
		{0.9999988234517019099290257101715260190483, 0.001533980186284765612303697150264079079955    },
		{0.9999997058628822191602282177387656771163, 0.0007669903187427045269385683579485766431409   },
		{0.9999999264657178511447314807073878569482, 0.000383495187571395589072461681181381263395    },
		{0.9999999816164292938083469154029097145051, 0.0001917475973107033074399095619890009334689   },
		{0.9999999954041073128909719331396061489589, 0.00009587379909597734587051721097647635118707  },
		{0.9999999988510268275626733077945541084005, 0.00004793689960306688454900399049465887274687  },
		{0.9999999997127567068494139722186417760891, 0.00002396844980841821872918657716502182009476  },
		{0.9999999999281891767097750958838504902605, 0.00001198422490506970642152156159698898480473  },
		{0.9999999999820472941772826241477841073796, 0.000005992112452642427842879711808890861729987 },
		{0.9999999999955118235443105841729973244415, 0.000002996056226334660750454812808357059811825 },
		{0.9999999999988779558860770165517525365038, 0.000001498028113169011228854278846155361120692 },
		{0.9999999999997194889715192147947195844520, 0.000000749014056584715721130498566730655637156 },
		{0.9999999999999298722428798012397287367582, 0.0000003745070282923841239031691790846331773974},
	};

	auto data = span.data;

	u32 nn = N >> 1;
	u32 ie = N;
	for (u32 n = 1; n <= LogN; n++) {
		auto w = ws[LogN - n];
		auto in = ie >> 1;
		Complex<Float> u = {1, 0};
		for (u32 j = 0; j < in; j++) {
			for (u32 i = j; i < N; i += ie) {
				auto io = i + in;
				auto tp = data[i] + data[io];
				auto tq = data[i] - data[io];

				data[io] = tq * u;
				data[i] = tp;
			}

			u *= w;
		}

		ie >>= 1;
	}

	for (u32 j = 1, i = 1; i < N; i++) {
		if (i < j) {
			auto io = i - 1;
			auto in = j - 1;
			auto tp = data[in];
			data[in] = data[io];
			data[io] = tp;
		}

		u32 k = nn;

		while (k < j) {
			j = j - k;
			k >>= 1;
		}

		j = j + k;
	}

	return true;
}

template <class Float>
void time_domain_to_frequency_domain(Span<Float> span) {
	scoped_allocator(temporary_allocator);

	List<Complex<Float>> complexs;
	complexs.reserve(span.size);
	for (umm i = 0; i < span.size; ++i) {
		Complex<Float> v;
		v.real = span.data[i];
		v.imaginary = 0;
		complexs.add(v);
	}
	fft(as_span(complexs));
	for (umm i = 0; i < span.size; ++i) {
		span.data[i] = length(complexs.data[i]);
	}
}

}
